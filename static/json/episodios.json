{
    "episodios": [
        {
            "data": "2017-11-30T00:00:00",
            "titulo": {
                "resumido": "Atomic Design",
                "completo": "Lançamento do podcast! Você já ouviu falar sobre Atomic Design?"
            },
            "subtitulo": "Parte 1",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep1-atomic-design.mp3",
            "duracao": "08:41",
            "texto": "Oi.\n\nEste é o primeiro episódio de um podcast sobre programação que está em construção.\nSe você estiver ouvindo pelo browser, pode perceber o que eu estou dizendo só de olhar para a página onde está o player.\nEste é o ELEMENCAST e eu, Luigui Delyer, tentarei trazer alguns drops de conteúdo de no máximo 10 minutos toda semana. O objetivo aqui é aprender ainda mais sobre programação.\nFalaremos sobre front-end, javascript, css, html5, metodologias de projetos, componentização, nodejs, mapas e gis, programação funcional e uma vida como programador organizada em elementos...\nEu inicío esse podcast hoje já falando de um tema que tenho gostado muito e gostaria de compartilhar com você como tem sido desenvolver no front de forma atômica e pra isso, precisamos começar falando diretamente sobre uma metodologia de projeto que me agrada muito, o Atomic Design.\nSe você nunca ouviu falar sobre isso, eu te digo de uma forma simples rápida:\n\nAtomic Design nada mais é do que uma forma de desenhar projetos.\nSeja na documentação, no layout, na forma com que criamos os testes, como separamos os arquivos, como pensamos nas funcionalidades do programa, na forma com que vamos reusar o código, entre outros.\nExistem diversas outras formas de fazer isso, algumas bem conhecidas são DDD e SOLID. Você pode ter lembrado do famoso MVC também, porém, ele não entra nesse caso já que o padrão MVC não é um design pattern propriamente dito.\nEu escolhi Atomic Design porque me deparei com o fato de que eu consigo levar essa maneira de pensar pra quase qualquer coisa que esteja relacionada a forma com que eu programo algo.\n\nDurante os próximo episódios nós conversaremos a fundo sobre como funciona isso e teremos uma série especializada no tema. Descobriremos qual tecnologia usar e como  chegar na conclusão de que nosso software precisa ser componentizado, atômico e reativo.\nNas próximas semanas também, eu terei aqui comigo, alguns amigos que nos ajudarão a entender ainda mais alguns dos temas que eu citei logo no início.\nNeste primeiro episódio eu irei explanar superficialmente os conceitos básicos de Atomic Design, mas pra isso, precisamos de teoria e vamos voltar um pouco nos tempos da escola pra falarmos sobre um assunto muito antigo mas completamente atual.\n\nSegundo a Wikipédia, em física e química, modelo atômico é todo modelo científico que se usa para explicar os átomos e seus comportamentos.\nNo século V antes de Cristo, alguns filósofos defendiam o atomismo, pois acreditavam que dividindo a matéria em pedaços cada vez menores, seria possível encontrar partículas que seriam invisíveis ao olho humano e, segundo esses pensadores, os átomos filosóficos vêm em uma variedade infinita de formas e tamanhos cada uma delas sendo indestrutíveis, imutáveis e cercadas por um vazio onde colidem com outras partículas ou se reúnem em algo que hoje chamamos de moléculas, organismos e matéria.\n\nPartindo desse princípio, nasceu a proposta de que o todo, se compõe não só de átomos ou partículas indivisíveis de natureza idêntica. Aí então nasceu a teoria da unidade e imutabilidade do ser.\nAcredita-se que vácuo e matéria desde a eternidade interagem entre si dando origem ao movimento, e que os átomos apresentam as propriedades de: forma, movimento, tamanho e impenetrabilidade, e, por meio de choques entre si, dão origem a objetos.\nUm desses filósofos, defendia que a matéria era descontínua, portanto, ao invés dos corpos macroscópicos que nós vemos, os corpos microscópicos ou os átomos não podem ocupar o mesmo espaço no tempo nem podem ser divididos, sendo suas mudanças observadas em fenômenos físicos e químicos como por exemplo a junção ou separação dos átomos e que qualquer matéria é resultado da combinação dos átomos dos quatro elementos básicos: ar; fogo; água e terra.\n\nTá, e o que programação tem a ver com nisso?\n\nO criador do Atomic Design, Brad Frost, desenhou cinco camadas básicas de divisão unindo todo esse conceito aí que você ouviu agora. No pensamento dele, nosso software pode ser separado por ÁTOMOS, MOLÉCULAS, ORGANISMOS, TEMPLATES e PÁGINAS.\nE há pouco tempo atrás, estudando mais sobre a metodologia, eu encontrei lugar para mais dois elementos os BÓSONS e os QUARKS.\nEu vou explicar um por um, relaxa.\n\nÁTOMO\nUm elementos mínimo presente em uma interface gráfica.\nNo mundo dos componentes eles são labels, inputs, campos de formulário, botões, títulos, parágrafos, etc.\n\nMOLÉCULA\nSão dois ou mais átomos mantidos juntos para funcionarem com um propósito único.\nUma molécula seria então um input junto com um botão que juntos, tem a função de busca numa interface gráfica.\n\nORGANISMOS\nNaturalmente, são duas ou mais moléculas que começam a moldar a navegação e a leitura do conteúdo nessa interface.\nAumentando o exemplo, a molécula de busca ao lado da molécula de navegação e do logotipo, faz parte do organismo header.\n\nTEMPLATES\nBom, você já deve ter entendido que estamos falando cada vez mais sobre abstrações da interface, né? Os templates consistem em vários organismos combinados para formar páginas.\n\nPÁGINAS\nE as páginas são uma evolução natural dos templates. Ou seja, são os layouts em si.\nLembra que eu disse que encontrei o caso de uso pra mais dois elementos?\n\nBÓSONS\nSão aquelas “coisinhas” que fazem uma grande diferença no visual e legibilidade de uma interface. Eles não precisam ser literalmente visíveis, pois são abstratos, como paletas de cores, fontes, animações e aspectos ainda mais invisíveis de uma interface como grids.\n\nQUARKS\nUm cara desses nunca é encontrado isoladamente, isto significa que um Quark só existirá quando existir um elemento completo.\nComo por exemplo, itens que enviam feedback para o usuário, como barras de progresso ou rolagem, validações em formulário, hints, dicas, tips de ajuda e etc...\n\nOu seja, imagina agora que tudo isso junto na mesma página tem uma vida própria, um escopo muito reduzido e uma capacidade natural de interagir entre si. Como cada item desse é um componente vivendo no seu app, você precisa ter um orquestrador, digamos assim, e é aí que entra o conceito de controle de estados imutáveis e reatividade entre todos os componentes... \n\nAfinal, quando você clicar no átomo de botão que está dentro da molécula de busca, o organismo de conteúdo precisará ser atualizado dentro do template de pesquisa para renderizar a página com o resultado...\n\nTá... Acho que agora você deve estar pensando em que é coisa pra caramba pra controlar e que é muito difícil abstrair tudo e começar a pensar assim... Bom... Eu preciso te dizer que não, é bem pelo contrário... Imagina que como eu disse agora pouco, o mundo funciona assim, a natureza rege tudo dessa maneira, então cabe a nós darmos continuidade na forma natural da vida dentro do nosso mundo digital.\nQuando você fizer isso, vai começar a perceber e será natural a aplicação de vários conceitos de programação funcional (que falaremos em breve), funções puras, códigos explícitos, escopos mínimos, reatividade natural, componentização obrigatória e também da coisa mais desejada de todos os programadores e gestores de TI... \n\nREÚSO DE CÓDIGO DE VERDADE!\n\nEu te garanto que a partir do momento que você decidir usar Atomic Design no seu dia a dia como programador, sua produtividade aumentará absurdamente.\nBom, o que eu tinha pra te dizer hoje era isso. Eu queria instigar sua curiosidade pra que você pesquise mais sobre o assunto e me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter que eu tô bolando pra te avisar quando os próximos conteúdos ficarem prontos e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida sobre qual metodologia usar naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este.\nUma comunidade forte, é uma comunidade unida que se ajuda.\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2017-12-07T00:00:00",
            "titulo": {
                "resumido": "Atomic Design",
                "completo": "Tá, quero separar tudo em componentes! Como ficam os entregáveis? Os arquivos mesmo..."
            },
            "subtitulo": "Parte 2",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep2-atomic-design.mp3",
            "duracao": "12:12",
            "texto": "Oi.\n\nEste é o segundo episódio de um podcast sobre programação que continua em construção.\nEste é o ELEMENCAST e eu, Luigui Delyer, tentarei trazer alguns drops de conteúdo toda semana.\nAntes de começar hoje, eu preciso agradecer muito a cada um que parou o que estava fazendo pra me ouvir e interagir comigo nos últimos dias... Foram inúmeros feedbacks positivos e foi surpreendente ver a quantidade de pessoas que se interessaram pelo assunto! Fico feliz em saber que vamos trilhar um caminho legal pela frente. Então já sabe, vem trocar ideia comigo em alguma das minhas redes sociais que estão no site do ELEMENCAST.\nUm dos feedbacks que eu recebi é que só dei exemplos de uso do Atomic Design em interfaces gráficas e aí o pessoal que manda bem em NodeJS e outras soluções pra backend e que não é muito feliz com CSS e design, ficou meio sem ver o valor que a metodologia poderia ter no back. Eu preciso dizer que sim, Atomic Design pode ter um lugar aí no seu coraçãozinho sem layout no back também.\n\nNo primeiro episódio, eu falei de uma forma bem básica e suave o conceito principal do Atomic Design. Hoje, eu vou aprofundar um pouco mais, tratando a forma que ficam os entregáveis, como é a interação do time durante o desenvolvimento do sistema e qual é o papel de cada um no processo de criação do app, também vou falar um pouquinho mais de programação funcional também, afinal pra mim, Atomic Design e programação funcional, são almas gêmeas.\nO lance principal é que a metodologia pretende te forçar a pensar em abstração de código e te fazer olhar sempre pra menor parte do app e ir 'subindo'...\n\nSe você está construindo uma API Rest em NodeJS com Express por exemplo, você pode pensar que sua rota tem uma função e essa função é uma página (lembre-se que página aqui não é literalmente uma que poderá ser renderizada por sua rota e sim o elemento de abstração mais alto do Atomic Design a função em si).\nAgora pense que essa função só tem uma obrigação, chamar as outras funções que constroem o 'template' passando os parâmetros da rota. Só aqui, já começamos a ter funções puras e modularização natural. O template seria o conteúdo principal, uma espécie de core da sua rota e dentro dele, nós chamaremos as funções 'menores' digamos assim passando mais parâmetros, até chegar naquela sua função que tem o único propósito de devolver um array filtrado de dados, por exemplo.\n\nPercebe que só de termos chegado nessa função minúscula de filtrar um array, já nos deparamos com uma situação que nos fará escrever um código com mais qualidade e que isso será completamente natural e involuntário... Uma função que filtra um array é automaticamente reusável. É uma função pura que tem um escopo muito reduzido, um input explícito (que seria o nosso array bruto) e um output explícito (que será o array filtrado).\n\nParece até chato ficar repetindo isso de função pura e etc, mas é que eu realmente quero que isso fique fixado na sua mente e que você não pare de pensar nisso. Assim que você ver o seu código, quero que você fique com vontade de refatorar aquela função gigante que você escreveu ontem e que manipula 10 objetos globais...\nEsse inclusive é aquele momento ótimo pra você aprender a não usar mais for's e while's... Sim, essa vida de loops não te pertence mais... Nós podemos fazer 99,99% de todos os loops de dados usando as três funções principais de iteração map, filter e reduce.\nVocê já deve ter visto essas três palavrinhas em algum lugar da web que falava de ES6 ou das novidades de Javascript...\nTem muito artigo bom na internet sobre isso e eu recomendo fortemente o artigo do Vinicius Reis que tem o título: “Reduce, mais um dia sem loops.”. Você pode encontrar esse artigo facilmente lá no Medium ou usando seu buscador favorito. Em breve, eu abordarei cada um desses temas aí, assim, aprenderemos como é isso de viver sem loops.\n\nVocê só não pode esquecer de fazer uma função genérica com inputs e outputs definidos e com isso automaticamente você estará fazendo um código reusável e que não gera efeitos colaterais em outras partes do seu app.\n\nEFEITOS COLATERAIS? COMASSIM?\n\nToda função que não é pura, ou seja, que manipula um valor dentro dela que não foi passado por um parâmetro, está alterando um pedaço fora do escopo dela mesmo. Ou seja, está provocando um efeito colateral em algo que talvez você não queira... Se uma variável global define uma URL e você altera esse endereço dentro da função, todas as outras funções receberão esse valor alterado e isso poderá te gerar um problema sem tamanho... Sem contar que manipular dados assim, tiram qualquer característica de reuso dessa função... Você terá de escrever sempre uma função nova pra fazer coisas diferentes só que fazendo a mesma coisa...\nReuso de código é um desejo de todos! Sempre foi... Escrever menos, produzir mais, produzir melhor, produzir sempre\nE para que essas funções todas sejam reusáveis você precisará modularizar seu código inteiro, então logo nós teremos vários arquivos com poucas linhas de código que serão módulos exportando código pra outros módulos e em algum momento, você terá uma função que passa outra função como parâmetro para receber um valor lá de longe. E toda vez que você fizer isso, estará criando e usando alguns conceitos de programação funcional como High Order Function, First Class Function e Lambda Function. Se você não sabe o que são esses temas, pode ficar sossegado porque em um dos próximos episódios nós abordaremos esse assunto com quem manja de verdade.\n\nEssa forma de programar e pensar em módulos já é uma realidade no front e no back. Se você usa React, Vue, Angular, Mithrill ou qualquer outro framework JS com algum pré-processador de arquivos como Webpack, Rollup, Browserify, Gulp ou Grunt, você sabe do que estou falando.\nA facilidade de importar e exportar códigos e fazer essa conexão entre arquivos não se limita a Javascript, várias outras tecnologias de front também possuem essa capacidade. Por exemplo SASS, Stylus e LESS que são pré-processadores de CSS e a linguagem de templates PUG fazem importação de módulos desde sempre. E particularmente, quem me conhece sabe o quanto eu adoro PUG e SASS.\n\nLembre-se, não é obrigatório seguir o fluxo proposto pelo Atomic Design de 'página > template > organismo > molécula > átomo'. Se você precisar ir de 'página' pra 'átomo' diretamente, tudo bem! Só não esqueça que o fluxo do dado é sempre do menor para o maior e que as chamadas das funções partem sempre das maiores pras menores. Ou seja, você não pode fazer um átomo chamar outro átomo que chama outro átomo, que chama mais um outro átomo... Não faz sentido isso... Você precisa orquestrar essas chamadas.\n\nMas então e esse monte de arquivinhos espalhados na minha pasta SOURCE, e agora? O ATOMIC DESIGN é bem flexível quanto a isso e o que eu vou te falar aqui agora é o jeito que EU faço, é a MINHA preferência pessoal e eu te indico fortemente essa maneira, pois ela é um catado geral de vários projetos que eu já acompanhei sendo criados com a metodologia e a soma da experiência que eu já tive fazendo projetos por onde passei.\nDentro do seu diretório 'source' ('/src'), crie um sub-diretório chamado 'componentes' e dentro dele crie mais alguns sub-diretórios chamados 'atomos', 'moleculas', 'organismos', 'templates' e 'paginas', assim mesmo, no plural. Se você preferir, pode criar em inglês também, lembre-se que essa é uma escolha totalmente sua, o mais importante aqui é saber diferenciar a hierarquia das coisas, o seu código dentro desses diretórios é mais importante do que o nome deles em si. No seu bundle, essas pastas não terão nenhum valor, então foca na funcionalidade!\n\nO conteúdo de cada um desses diretórios poderá ser outros diretórios nomeando os componentes e isso quem controlará será você, seu framework e o seu time. Como por exemplo, se você está desenvolvendo um webapp com VueJS, você 'não precisa' de pastas. Os 'Vue Single File Components' já contém tudo relacionado ao seu componente. Porém, se estiver usando React com SASS ou Angular com HTML e CSS externos, terá de criar uma pasta para cada componente e dentro dela, todos os arquivos relacionados a ele.\nÉ válido lembrar que se você criar diretórios para cada componente o restante do time poderá atuar individualmente em cada um deles, já que a metodologia visa integrar equipes inteiras e agilizar a entrega de protótipos, wireframes e layouts para que todos tenham tempo de focar em partes específicas, estratégicas e na qualidade do código que será entregue ao cliente.\nComo por exemplo, a equipe destinada a documentar o código poderá colocar o arquivo Markdown da documentação do componente dentro da sua respectiva pasta. O designer poderá colocar o arquivo JPG de como deverá ser o layout do componente no final, O Dev que gosta de escrever os testes poderá deixar o arquivo '.spec' dele lá dentro também e assim sucessivamente... Tudo que for relacionado a esse componente deve estar dentro da pasta dele.\nNo lugar de serem entregues inúmeros arquivos em PSD ou JPG pro cliente ficar aprovando e depois os Devs ficarem fatiando e refazendo a cada alteração, você vai conseguir concentrar tudo num repositório de padrões de interações que serão usadas pelo webapp e com as interações já funcionando. Afinal, cada componente tem vida própria, lembra? Eles são independentes e estarão funcionando de forma ordenada, em conjunto com o todo. Mesmo se eles não possuírem lógica, como por exemplo se foram apenas de HTML e CSS você já terá uma noção real de como ficará o app em diversos tamanhos de telas, como serão as animações e etc...\n\nSim, serão muitos arquivos. Esteja preparado pra isso. Tenha em mente o lado positivo da coisa, você terá uma responsabilidade menor de código com cada um deles e acima de tudo está construindo um código escalável tanto no layout quanto em documentação, testes, performance, qualidade e legibilidade de código por estar sempre pensando do menor para o maior e com isso, atingindo todas as áreas.\nParticularmente também, você pode escolher pular alguma dessas etapas, como por exemplo, as vezes eu não crio nenhum componente do tipo 'página'. Dependendo do projeto, os componentes do tipo 'template' são suficientes. Então, se você se deparar com uma necessidade de pular alguma camada mais alta de abstração, fique a vontade. Você só não poderá pular a etapa dos 'átomos', pois ela é a base de tudo. Lembre-se, Atomic Design te fazer olhar de baixo pra cima, do menor pro maior. É importante frisar isso.\n\nÉ só lembrar o que eu disse no episódio anterior que qualquer matéria é resultado da combinação dos átomos. E que a matéria é descontínua, ou seja, nós vemos corpos macroscópicos que são a junção de corpos microscópicos. Esse fluxo da natureza precisa ser levado pro seu app e pro seu time. Sempre!\n\nNão pense você que quando eu falo desse fluxo 'AUTOMÁGICO' e 'BALA DE PRATA' estou dispensando o designer de Interação, assim como também não devemos eliminar a necessidade de desenhar uma página inteira. É importante que seja formada uma equipe multidisciplinar (UX, UI, Fronts, Backs, Analistas, Engenheiros, etc.) e que cada um consiga dar o seu melhor em cada componente.\n\n\nBom, o que eu tinha pra te dizer hoje era isso. Eu queria instigar sua curiosidade pra que você pesquise mais sobre o assunto e me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter que eu tô bolando pra te avisar quando os próximos conteúdos ficarem prontos e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida sobre qual metodologia usar naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este.\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui. Até a próxima."
        }
    ]
}
